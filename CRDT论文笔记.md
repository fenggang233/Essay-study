# CRDT

### 介绍

最终一致性从某种程度上可以提高分区容错性。因为一部分操作可以先应用在本地系统上，随后再异步地发送给其他系统。只要求最终所有的复制系统能够应用所有的ipdate操作。

CRDT的可应用领域：
> 时延容忍网络，广域网中的延迟容限，断联操作，耐搅动的点对点计算，数据汇总，云计算的分区容限


### 系统模型

用atom表示常规的不可交换的数据类型，比如int,char....

用object表示可变的，可复制的数据类型。object具有标识符，内容(payload)，内容可能是任意数量的atom或是object，还具有一个初始状态，一个包含了操作的接口。

若是两个object有相同的标识符但处于不同的两个进程中时，我们称其中的一个是另一个的副本。

我们的用户会通过调用操作接口来查询和修改object的状态，他们初始操作的副本我们称为源副本。

查询仅在本地副本系统（进程）实施，而更新包括两端：首先客户在本地副本调用操作，执行一些初始的操作，随后更新操作异步传输到其他所有的副本

基于状态的副本：更新操作完全在源处发生，然后通过在副本之间传输修改后的有效负载进行传播。

基于操作的副本：在基于操作的副本中，更新分为两段式，前一段从操作调用中获取参数。 不允许产生副作用； 它可以计算结果，返回给调用者，和/或为第二阶段准备参数。第二段则会在第一段结束后立即发生在本地，并异步地发生在其他副本系统上。

### 收敛

定义：（最终收敛性）两个x的副本xi和xj在以下条件均满足时是最终收敛的：
1. xi和xj的抽象状态是相等的
2. 若f属于C（xi），则最终有：f属于C(xj)

状态相等的含义：对所有的查询均返回相同值

#### 基于状态的CRDT(CvRDT)
1. 规定了least upper bound，也就是最小上界
2. 规定了Join Semilattice，它是一个有序集合，且集合中任意两个元素都有最小上界

一个基于状态的对象，其有效载荷采用半格形式，并且merge（x，y）def =x⊔vy，朝初始值和更新值的LUB收敛。 此外，如果更新根据≤v单调向上（即，更新之后的有效载荷值大于或等于之前的值），则它会收敛到最新值的LUB。 让我们将此组合称为“单调半格”。
有上述属性的我们称为CvRDT。

最终收敛要求所有的副本都接收到所有的update操作，由于合并是幂等且可交换的（通过⊔v的属性），只要新状态最终通过直接合并直接或间接到达所有副本，消息可能会丢失，乱序接收或多次接收。 只要最终恢复连接，即使网络分区，更新也可以可靠地传播。

任何两个CvRDT的复制object都是最终收敛的，只要系统通过最终可靠的点对点通信持续进行成对副本之间的负载传递

#### 基于操作的CRDT(CmRDT)
对于一个op-base的object，一个可靠的广播频道会保证所有的更新都依据数据结构指定的传输顺序<d传输到所有的副本。没有被<d约束的操作称为并发操作，若所有的并发操作都是可交换的，则最终所有的副本收敛到相同状态。这样的object称为CmRDT

任何两个CmRDT的副本是最终收敛的，只要系统通过可靠广播频道按照传输顺序<d传输操作

#### CvRDT与CmRDT
CvRDT所有的信息都可以通过状态获取，它们需要较弱的通道假设，允许未知数量的副本。但每次都发送较大的object效率较低，这一点可以通过转而发送状态的改变量来优化，但这种优化需要部分参考op-base型的实现。

指定基于操作的对象（CmRDT）可能会更加复杂，因为它需要对历史进行推理，但是相反，它们具有更大的表达能力。 有效载荷可以更简单，因为某些状态已有效地卸载到通道。 基于Op的复制对频道的要求更高，因为它需要可靠的广播，而广播通常需要跟踪组成员身份。


### 一些CRDT

#### Counters
支持增和减更新操作，支持值查询。该对象的指朝着全局增量减去全局减少量收敛。

Op-base counter：
负载是整数，更新操作的一阶段是空，二阶段只做本地的加减操作，加减可交换，所以是CmRDT

state-base increment-only counter：
负载是整数向量，每个副本指定为向量的某个元。每个副本的操作都只记录到其在向量的对应元中。值就是向量所有元素之和。两个状态可以通过其中某一个元的大小关系来推断（因为单增），merge操作对每个元取最大值。
但这种设计要求：1不会溢出，2副本数已知

state-base PN-counter：
包含两个G-counter，它的负载包括两个向量，一个用来记录增量，一个记录减量

Non-negative Counter：
一种强约束方法是使用本地变量记录发生在本地的操作，并要求本地的减量不能超过增量，但这种约束可能会太强。其他的实现方式也不太理想

#### register
后写覆盖先写，一般情况下并发更新不可交换

LWW-register：
通过将时间戳与每次更新相关联来创建写的总顺序。时间戳被认为是唯一的，完全有序的并且与因果关系一致。

state-base LWW-register：赋值操作更新负载并生成新的时间戳。merge选取较新的时间戳对应结果返回

op-base LWW-register：赋值时在源副本生成时间戳，二阶段时，仅当新的时间戳比当前的新才执行更新操作

Multi-value register：
负载应该是多个值+时间戳组成的数据对，merge操作合并每个元素中时间戳较新的那个

#### Set
由于集合的加入和移除是不可交换的，因此一个集合不能既是CRDT又满足集合的顺序规则

Grow-only set：
最简单的实现方式是去除remove操作，它的op-base和state-base型的G-set实现中，负载都是一个集合
op-base：由于集合的add操作可交换，所以最终收敛，是CmRDT。
state-base:
定义状态S，T的偏序关系<= ：S<=T等价于T包含S
merge操作是取两个集合的并

2P-set：
我们规定这种集合可以增和减，但是不能增加（add）曾经add过的元素。2P-set一般使用两个G-set实现，一个包含增添的元素，一个包含remove的元素。仅当观察到集合中存在某个元素时才允许进行remove操作。
state-base 2P-set：负载包含一个本地集合A用于adding，一个本地集合R用于removing。查询操作检查某个元素是否在A中且不在R中。merge操作分别合并两个A和两个R
op-base 2P-set：并发add相同的元素，并发remove相同的元素可交换，对不同的元素的并发操作可交换。

U-set：
若每一个元素均unique，每一个被remove的元素均不会再被add，并且传播到副本的每一次remove操作前总有对相同元素的add操作，就没必要记录remove的元素，只记录add的元素就可以了。

LWW-element-set:给每一个元素附上一个时间戳，负载仍然包含集合A和集合R，合并两个副本就取A集合的并和R集合的并。

PN-set：另一种方式是给每一个元素附上一个计数器，计数器初始为0，每加入一个元素，就给对应元素的计数器加1，remove就减1，当元素的计数器严格正时，认为该元素存在在集合里。
问题在于当一个元素的计数器为负值时，add这个元素的结果可能对应计数器仍然为负，则这个元素仍然被认为在集合中不存在。一种解决方式就是当向集合中加入一个计数器为-k的元素时，计数器的值增加k+1而不是1，但这又会导致remove的失效。。。。

Observed-Remove set：
支持add和remove，添加和删除序列的结果仅取决于其因果关系，并符合集合的顺序规范。
直觉是唯一地标记每个添加的元素，而无需在接口中暴露唯一的标记。 删除元素时，将删除在源副本处观察到的所有相关唯一标签，并且仅删除那些唯一标签。
op-base：负载是（元素，唯一标识）对的集合，add(e)会生成在本地副本唯一标识，随后传播到其他副本，两次add(e)会导致集合中存在两个不同唯一标识的e，但是查询是无视唯一标识的。
当客户在本地副本调用remove(e)时，所有相同e的所有唯一标识都被记录，随后被全部从本地副本删除，随后这些唯一标识被传播，其他的副本也按此删除。这样一来，并发的add(e)和remove(e)由于remove(e)处并没有新增加的这个e的唯一标识，因此并不会被删除
