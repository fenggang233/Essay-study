参考```https://zhuanlan.zhihu.com/p/60916031```

1. 需求：分布式系统主要解决哪些问题?主要应用场景有哪些?
2. 实现：构建分布式系统常见问题有哪些?解决这些问题的主流方案有哪些?
3. 技术难点：实现分布式系统的本质困难是什么?他们发展情况如何?
4. 工业应用：工业上正在构建哪些分布式系统?他们的发展情况如何?


### 基本问题和应用场景

1. 可扩展性
2. 高可用性，特别指通过软件系统的设计组合多个相对可靠性较低的设备对外提供更高的可用性

分布式系统可以通过在软件层面上协调多个终端共同工作来提供服务，满足对性能的要求，实际上，这也是一种使用软件对上层屏蔽下层细节的形式

完全屏蔽下层细节，尤其是屏蔽分布式系统和单机系统这一细节可能性较低，出于性能上的考虑，上层需要理解并一定程度上配合底层细节。

### 常见问题和解决方案

#### 最基础的问题：如何将分布式节点组织起来发挥作用

目前较为流行的组织方式：

1. Hybrid Decentralized：具有中心节点进行协调或索引，但其他部分是分布式的（HDFS，BitTorrent）
2. Partially Centralized：不具有中心节点，但具有super node，类似于DNS的结构，但每层的上一层都是选举出的super node
3. Purely Decentralized:完全分布式，节点完全对等
+ Unstructured:节点不组成固定结构，类似于物理路由器，只知道附近的几个邻居节点。查询需要依靠flooding或类路由
+ Structured:节点组成固定结构，比如环，多维空间，超立方体等

对于不具有中心节点的架构，还需要思考：
1. 哪些节点是当前覆盖网络的成员？membership protocol
2. 名字到位置的索引？naming service
3. 如何把信息从一个位置投递到目标位置？


#### 节点的协作

需要在分布式系统领域重新实现：
1. 临界区和锁
2. 原子性和事务

#### 数据的复制和一致性

分布式系统中一致性的困难来源于物理机之间的通信网络可靠性比物理机内部的通信可靠性低。

### 分布式系统的本质难点

1. 分布式系统中不存在全局时钟
2. 分布式系统中通信不可靠

### 工业应用

1. 分布式存储
2. 分布式计算
3. 分布式调度


参考```http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/```

# CAP

CAP中的A：百分之百的读写可用，可以认为是在任意时刻对任意节点发起的读或写请求都无需等待与系统中其他节点通信的结果，就可以进行正确响应。

那么如何判断是否发生了网络分区？实践中通常采用消息超时的机制进行判断，即如果两个节点之间的通信超时，则认为此时发生了网络分区。

但是当我们使用这种方式进行判断时，就发现延迟和可用性（A）是一回事，延迟低的时候节点之间可以正常通信，从而提供一致性。延迟高的时候我们认为发生了网络分区，或者等待延迟降低到足以在超时时间之内实现通信（此时我们放弃了百分百的可用性但保证了一致性），或者放弃节点之间通信直接进行响应（此时我们放弃保证一致性但提供百分百的可用性）。

目前越来越多的系统即使在没有发生网络分区时也不提供强一致性(CAP 中的C)，这是为了保证性能。

综上，在实践中，当发生了网络分区时，我们在C和A之间取舍；当没有发生网络分区时，我们在C和L之间取舍，这样CAP理论就拓展为PACELC理论

进一步考虑，我们之所以需要进行C和A的取舍或是C和L的取舍，根本原因是节点之间需要同步通信才能保证C。极端情况下，我们可以使得整个系统无需进行同步通信来达到极致的A和L（放弃C）。

从更大的角度来看，在一个不可靠的分布式系统中我们需要在safety和liveness之间进行取舍。例如一致性是一种safety性质，可用性则是一种liveness性质。在FLP问题中，对于一个共识问题，若有任意节点不可靠，则无法保证同时具备safety和liveness。

Paxos算法可以容忍系统中少数集合的节点失效。但它依然不能打破CAP定律，当发生网络分区时，假设分区将系统分成了一个多数集和一个少数集，尽管Paxos算法使得多数集中的节点仍然可以正确且立即回复请求，少数集的节点却不能这样。

CAP理论提出后，A Critique of the CAP Theorem 提出CAP理论中对于A和C的定义不够严格，一致性和可用性不是一个非0即1的离散变量，而是从0到100%的连续变化的变量。这篇论文将A定义为算法对latency的敏感程度，将C定义为算法所使用的并发一致性模型，将P定义为Latency的突发增长。

这样一来，A不再是对服务的一个观测结果，而是算法的一个本质属性，P的定义也能和A相结合。在这样的框架下，最终一致模型也能很好地进行建模和推理，最终得到结论，最终一致性的Replica算法在网络分区永久性的发生时仍然能够停机。

# ACID

ACID性质
1. 组成事务的多个事件要么都成功要么都失败
2. 执行事务的前后，数据库的状态保持（应用程序层面）一致
3. 并发执行的事务之间不相互影响
4. 已经提交的事务不会丢失

# CAP与ACID

一致性中的linearizability和数据库事务执行的serializability

其中linearizability是在具有多个副本的单个对象的情况下，对于并发操作的执行顺序约束，形象地表达就是它执行的结果等价于按照真实时间顺序，依次（非并发）地执行这些事件
而serializability则只要求多个事务执行的结果等价于这些事务依次（非并发）执行的结果，并不约束这些事务的执行顺序

# 我们要做什么

1. 在满足传统数据库强一致性约束下，能做到多高的可用性和多低的延迟？
2. 在满足100% read write availability的约束下，能做到多高的一致性
3. 两者之间还存在什么联系


