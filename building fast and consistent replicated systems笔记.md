1. 在一个提供多级一致性的系统中如何判断在什么条件下让什么操作使用弱一致性？（红蓝一致性）
2. 上述分类是否可以自动化实现？（SIEVE）
3. 是否有一种通用的方式表达各种一致性要求并利用它来最大程度减少所需的协调通信量，实现性能最优？（细粒度的一致性）（部分有序限制POR一致性理论）

# Gemini
相反，我们首先乐观地在其主站点上运行了生成器操作，然后根据本地状态和用户输入推测性地生成了一个暂定的影子操作。如果相关的影子操作是蓝色的，那么本地站点就可以立即响应该操作而不需要联系远程的复制系统。否则，副本系统之间就必须相互通信为所有的红色影子操作建立一个统一的顺序，并确保这个影子操作的生成状态符合要求

对生成器操作的要求：
1. 它们不应该干扰其他的并发操作
2. there is no need for them to make their identified side effects persistent（？）

综上，认为基于锁机制的并发控制解决方案过于保守，转而使用乐观并发控制（OCC）。

1. 使用时间戳来决定影子操作能否成功完成，即影子操作能否被其他站点接受并按序加入全局的红蓝序序列中，为了确保不同的站点不会把一个红色操作的序列号发给不同的两个红色操作，我们使用一种令牌传递方案，只有持有令牌的站点中的协调器有权赋予红色操作在全局红蓝序中的序列号
2. 当生成器操作完成后，相关的影子操作也已生成完毕并使用先前算法进行了上色，这些操作随机被送往协调器来判断是否与全局的红蓝序相适配。若操作为蓝，协调器只进行一个时间戳的连贯性检查，若是红色，协调器就要判断生成该操作的状态是否反映了在其之前的一组红色操作应用在“初始状态”后的状态。
> 检查方式：首先协调器等待自己所属的站点获取令牌，随后协调器进行读写冲突检查：1.请求待定操作要写数据对象的锁，防止本地的并发挂起影子操作继续进行2.检查挂起影子操作的读数据集合是否已经被其他已接受的且接受时间是在生成当前影子操作到进行读写冲突检查之间的影子操作上锁和修改
3. 将蓝色操作标记为只读的（性能提升）

# 未来可以考虑的工作和当前解决方案的限制
1. 红蓝一致性提供的是一种粗粒度的分类方案，当应用需要比强一致性和弱一致性更细的一致性划分时，使用当前方案可能会导致较保守的红蓝分类（红多蓝少）
2. 人工在并发的应用环境下进行操作可交换的判断，影子操作的生成等工作较困难，需要自动化工具
3. 使用令牌传递方案来提供强一致性效率和容错性较低，可以考虑paxos
4. 每个站点对于接收到的所有操作都会分配单调时间戳，导致其内部的所有操作是完全有序的，但蓝色操作本来是可以不需要有序的，我们这种全排序的行为会限制站点的并发量和性能。

看到这里出于兴趣去找了找有关paxos的论文

# paxos
三种角色：proposers，acceptors，learners

消息传递模型的前提：
1. 代理以任意速度运行，操作可能因为中途停止而失败，可能会重启。代理在失败并重启后要能仍保存失败之前的一些信息。
2. 信息可以经过任意长的时间送到，可以重复，可以丢失，但不会损坏。

P1. acceptor必须接受它收到的第一个提案
（问题是若两个提案分别被一半的acceptor接收到，那就没办法选出一个唯一的值）

现在我们要求每个提案必须包含一个提出时间和一个value，且任意两个提案的提出时间一定不一样。

P2. 若一个value=v的提案被选择，那么任何提出时间在它之后的提案都有v这个value

P2a. 若一个value=v的提案被选择，那么任何提出时间在它之后的任何被acceptor接受的提案都有v这个value

考虑到P1，加强P2a为：

P2b. 若一个value=v的提案被选择，那么任何提出时间在它之后的由任何proposer提出的任何提案都有v这个value

根据 P2b 难以提出实现手段。因此需要进一步加强 P2b。 

P2c. 如果一个编号为 n 的提案具有 value v，该提案被批准(chosen)，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于 n 
的任何提案，要么他们已经接受（accept）的所有编号小于 n 的提案中编号最大的那个提案具有 value v。

由此，要满足P2c的约束，proposer提出一个提案前，首先要和足以形成多数派的acceptors进行通信，获得他们最近一次接受的提案，之后根据回收的信息决定这次提案的value，形成提案开始投票，当获得多数acceptors接受后，提案获得批准，由acceptor将这个消息告诉learner。

此外，如果一个没有接受过任何提案的接收者在准备过程中回答了一个proposer针对提案n的问题，但在开始对n进行投票前又接受了编号小于n的另一个提案，若n和n-1有不同的value，这个投票就会违背P2c，因此在prepare过程中，acceptor进行的回答同时也应该包含承诺：不会再接受编号小于n的提案

P1a. 当且仅当acceptor没有回应过编号大于n的prepare请求时，acceptor接受（accept）编号为n的提案。

通过一个决议分为两个阶段：

    1. prepare阶段：
        + proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派；
        + acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；
    2. 批准阶段：
        + 当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value（如果根据P2c没有已经接受的value，那么它可以自由决定value）。
        + 在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求。

这个过程在任何时候中断都可以保证正确性。例如如果一个proposer发现已经有其他proposers提出了编号更高的提案，则有必要中断这个过程。因此为了优化，在上述prepare过程中，如果一个acceptor发现存在一个更高编号的提案，则需要通知proposer，提醒其中断这次提案。 

根据上述过程当一个proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个proposer在这种情况下都转而提出一个编号更大的提案，就可能陷入活锁，违背了Progress的要求。一般活锁可以通过 随机睡眠-重试 的方法解决。这种情况下的解决方案是选举出一个leader，仅允许leader提出提案。


## SIEVE

贡献
1. 操作的可交换性转型。SIEVE可以自动将有副作用的应用操作转型为可交换的形式。
2. 高效率的涂色。静态部分+运行时检查
3. 最少的人工干预

看到这里去查了一下CRDT的内容
参考了这里，以获得crdt的一个大致认识。
```https://juejin.im/entry/5b922d336fb9a05ce7513cff```
```https://liyu1981.github.io/what-is-CRDT/```

> CAP理论
> 可用性，一致性，分区容错性（整个分布式系统由于故障导致网络不畅通，整个系统临时被分成几个相互独立的区并仍在向外界提供服务，此时若数据只保留在单个节点中，其他区就会访问不到这个数据，即分区容忍性低，一般认为分布式系统必须满足分区容错性）只能三选二。
> 选择一致性，构建的就是强一致性系统，比如符合ACID特性的数据库系统。选择可用性，构建的就是最终一致性系统。
> CRDT的两种基本形式：基于状态的CRDT和基于操作的CRDT，前者存储的是一个个最终值，后者存储的是一个个操作记录

感觉上CRDT是对现有数据结构进行改造，使它能实现分布式系统中的信息同步？

### 设计原理
要能1生成可交换的影子操作，2给生成的影子操作上色

为了完成任务1，选择使用丰富的可交换复制数据类型（CRDT），他们的操作都是可交换的。CRDT可以用来生成影子操作，多个影子操作执行得到的系统最终状态相同，且这一结果和操作执行顺序无关。因此影子操作被构造为一系列对CRDT的update操作，这些update操作通过构造而可交换。

为了完成任务2，我们只需要判断它是否是不变量安全的。这个问题有两种解决方向：
1. 动态解决方案，运行时决定何时生成影子操作和影子操作是否符合不变量安全性
2. 静态解决方案，它确定要对初始操作类型，参数和初始状态使用哪种组合，从而导致生成不变量安全的影子操作

这里结合上述两种思路提供了一种静态动态相结合的解决方案

### 实现架构
应用程序程序员将应用程序代码编写为一系列用Java编写的事务，这些事务访问数据库以存储持久状态。除了应用程序代码之外，程序员唯一需要提供的其他输入是CRDT注释，该注释指定了合并并发更新的语义和一组特定于应用程序的不变量。

静态分析器随后根据每个事务的代码创建影子操作模板，其中这些模板表示CRDT库中函数的不同调用序列。 分析器还计算出每个模板始终安全所需的最弱前提条件。

在运行时，应用程序服务器同时运行java代码和运行时检查器，并和数据库服务器和复制层进行交互。

当执行一件事务时，应用服务会运行生成器操作并将所有的操作副作用进行合计，当生成器调用提交操作时，会创建一个影子操作，该影子操作由CRDT库中的一系列调用组成。

然后将此影子操作馈送到最弱的前提条件检查器，以确定它属于哪个静态模板，以及该操作保持不变量安全所需的前提条件是什么，被涂色的影子操作随后反馈到复制系统用于实现多级一致性

### 生成影子操作

1. 许多用用基于两层模型构建，其中所有的持久状态都存储在关系数据库中通过数据库命令进行访问
2. 利用CRDT
综上，我们可以专注于调整SQL命令的实现以访问CRDT。

但是由于相同的数据库操作可能有不同的语义，在一些语义选择方面我们必须要求开发者进行介入和说明

#### 运行时生成影子操作
有了开发者的模式注释，运行时生成可交换的影子操作就很简单了。

思路就是当接收到新的用户请求时调用原始操作，但是不同之处在于，对数据库中所有执行命令的调用都被修改后的JDBC驱动程序拦截，该驱动程序随着原始操作的进行而构建包括影子操作的CRDT操作序列。

### 影子操作的涂色
静态情况下执行最保守判断，若静态判断该操作为红色，动态判断时再进一步进行检查。在当前情况下可以遍历所有可能，因此执行静态判断几乎相当于查表。

代码里常规的循环情况可能会导致无穷多的CRDT操作，这种情况下需要程序员指定循环不变量指导最弱的前提计算。另一种方法是简化循环的情况从而得到一个较简单的解决方案。

简化的情况：在大部分时候，循环迭代是相互独立的，每次迭代中修改的状态部分是不相交的。基于这种简化的情况做了一些工作。

运行时计算：通过将此操作与其对应的模板进行匹配来获取其最弱的前提条件，通过用此操作携带的值替换条件中的变量来评估条件。

模板/影子操作匹配：在运行时，我们必须在静态分析过程中创建的字典中查找与每个影子操作对应的模板。执行此查找的挑战在于，它需要确定与采用的路径相对应的影子操作的标识符，并且必须通过仅考虑由运行时控制的操作（即CRDT操作）来完成此操作。 这解释了为什么词典键仅包含CRDT操作。 使用影子操作标识符，可以通过使用搜索树有效地将运行时采用的路径与字典中存在的键进行匹配。

最弱前提条件检查：最后，一旦检索到对应于特定阴影操作的模板的最弱前提条件，我们便会根据阴影操作的CRDT参数评估该前提条件。 这可以通过简单地将前提条件中的变量替换为其实例化的值并将最终表达式评估为true或false来实现。 如果评估最弱的前提条件为true，则将阴影操作标记为蓝色，否则将阴影操作标记为红色。

### future work
1. CRDT库不完整
2. 使用SIEVE运行非复制系统的应用程序会导致性能下降
3. 循环情况的全面考察
