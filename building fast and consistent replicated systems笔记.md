1. 在一个提供多级一致性的系统中如何判断在什么条件下让什么操作使用弱一致性？（红蓝一致性）
2. 上述分类是否可以自动化实现？（SIEVE）
3. 是否有一种通用的方式表达各种一致性要求并利用它来最大程度减少所需的协调通信量，实现性能最优？（细粒度的一致性）（部分有序限制POR一致性理论）

# Gemini
相反，我们首先乐观地在其主站点上运行了生成器操作，然后根据本地状态和用户输入推测性地生成了一个暂定的影子操作。如果相关的影子操作是蓝色的，那么本地站点就可以立即响应该操作而不需要联系远程的复制系统。否则，副本系统之间就必须相互通信为所有的红色影子操作建立一个统一的顺序，并确保这个影子操作的生成状态符合要求

对生成器操作的要求：
1. 它们不应该干扰其他的并发操作
2. there is no need for them to make their identified side effects persistent（？）

综上，认为基于锁机制的并发控制解决方案过于保守，转而使用乐观并发控制（OCC）。

1. 使用时间戳来决定影子操作能否成功完成，即影子操作能否被其他站点接受并按序加入全局的红蓝序序列中，为了确保不同的站点不会把一个红色操作的序列号发给不同的两个红色操作，我们使用一种令牌传递方案，只有持有令牌的站点中的协调器有权赋予红色操作在全局红蓝序中的序列号
2. 当生成器操作完成后，相关的影子操作也已生成完毕并使用先前算法进行了上色，这些操作随机被送往协调器来判断是否与全局的红蓝序相适配。若操作为蓝，协调器只进行一个时间戳的连贯性检查，若是红色，协调器就要判断生成该操作的状态是否反映了在其之前的一组红色操作应用在“初始状态”后的状态。
> 检查方式：首先协调器等待自己所属的站点获取令牌，随后协调器进行读写冲突检查：1.请求待定操作要写数据对象的锁，防止本地的并发挂起影子操作继续进行2.检查挂起影子操作的读数据集合是否已经被其他已接受的且接受时间是在生成当前影子操作到进行读写冲突检查之间的影子操作上锁和修改
3. 将蓝色操作标记为只读的（性能提升）

# 未来可以考虑的工作和当前解决方案的限制
1. 红蓝一致性提供的是一种粗粒度的分类方案，当应用需要比强一致性和弱一致性更细的一致性划分时，使用当前方案可能会导致较保守的红蓝分类（红多蓝少）
2. 人工在并发的应用环境下进行操作可交换的判断，影子操作的生成等工作较困难，需要自动化工具
3. 使用令牌传递方案来提供强一致性效率和容错性较低，可以考虑paxos
4. 每个站点对于接收到的所有操作都会分配单调时间戳，导致其内部的所有操作是完全有序的，但蓝色操作本来是可以不需要有序的，我们这种全排序的行为会限制站点的并发量和性能。

看到这里出于兴趣去找了找有关paxos的论文

# paxos
三种角色：proposers，acceptors，learners

消息传递模型的前提：
1. 代理以任意速度运行，操作可能因为中途停止而失败，可能会重启。代理在失败并重启后要能仍保存失败之前的一些信息。
2. 信息可以经过任意长的时间送到，可以重复，可以丢失，但不会损坏。

P1. acceptor必须接受它收到的第一个提案
（问题是若两个提案分别被一半的acceptor接收到，那就没办法选出一个唯一的值）

现在我们要求每个提案必须包含一个提出时间和一个value，且任意两个提案的提出时间一定不一样。

P2. 若一个value=v的提案被选择，那么任何提出时间在它之后的提案都有v这个value

P2a. 若一个value=v的提案被选择，那么任何提出时间在它之后的任何被acceptor接受的提案都有v这个value

考虑到P1，加强P2a为：

P2b. 若一个value=v的提案被选择，那么任何提出时间在它之后的由任何proposer提出的任何提案都有v这个value

根据 P2b 难以提出实现手段。因此需要进一步加强 P2b。 

P2c. 如果一个编号为 n 的提案具有 value v，该提案被批准(chosen)，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于 n 
的任何提案，要么他们已经接受（accept）的所有编号小于 n 的提案中编号最大的那个提案具有 value v。

由此，要满足P2c的约束，proposer提出一个提案前，首先要和足以形成多数派的acceptors进行通信，获得他们最近一次接受的提案，之后根据回收的信息决定这次提案的value，形成提案开始投票，当获得多数acceptors接受后，提案获得批准，由acceptor将这个消息告诉learner。

此外，如果一个没有接受过任何提案的接收者在准备过程中回答了一个proposer针对提案n的问题，但在开始对n进行投票前又接受了编号小于n的另一个提案，若n和n-1有不同的value，这个投票就会违背P2c，因此在prepare过程中，acceptor进行的回答同时也应该包含承诺：不会再接受编号小于n的提案

P1a. 当且仅当acceptor没有回应过编号大于n的prepare请求时，acceptor接受（accept）编号为n的提案。

通过一个决议分为两个阶段：

    1. prepare阶段：
        + proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派；
        + acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；
    2. 批准阶段：
        + 当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value（如果根据P2c没有已经接受的value，那么它可以自由决定value）。
        + 在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求。

这个过程在任何时候中断都可以保证正确性。例如如果一个proposer发现已经有其他proposers提出了编号更高的提案，则有必要中断这个过程。因此为了优化，在上述prepare过程中，如果一个acceptor发现存在一个更高编号的提案，则需要通知proposer，提醒其中断这次提案。 

根据上述过程当一个proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个proposer在这种情况下都转而提出一个编号更大的提案，就可能陷入活锁，违背了Progress的要求。一般活锁可以通过 随机睡眠-重试 的方法解决。这种情况下的解决方案是选举出一个leader，仅允许leader提出提案。


## SIEVE

贡献
1. 操作的可交换性转型。SIEVE可以自动将有副作用的应用操作转型为可交换的形式。
2. 高效率的涂色。静态部分+运行时检查
3. 最少的人工干预

看到这里去查了一下CRDT的内容
参考了这里，以获得crdt的一个大致认识。
```https://juejin.im/entry/5b922d336fb9a05ce7513cff```
```https://liyu1981.github.io/what-is-CRDT/```

> CAP理论
> 可用性，一致性，分区容错性（整个分布式系统由于故障导致网络不畅通，整个系统临时被分成几个相互独立的区并仍在向外界提供服务，此时若数据只保留在单个节点中，其他区就会访问不到这个数据，即分区容忍性低，一般认为分布式系统必须满足分区容错性）只能三选二。
> 选择一致性，构建的就是强一致性系统，比如符合ACID特性的数据库系统。选择可用性，构建的就是最终一致性系统。
> CRDT的两种基本形式：基于状态的CRDT和基于操作的CRDT，前者存储的是一个个最终值，后者存储的是一个个操作记录

感觉上CRDT是对现有数据结构进行改造，使它能实现分布式系统中的信息同步？

### 设计原理
要能1生成可交换的影子操作，2给生成的影子操作上色

为了完成任务1，选择使用丰富的可交换复制数据类型（CRDT），他们的操作都是可交换的。CRDT可以用来生成影子操作，多个影子操作执行得到的系统最终状态相同，且这一结果和操作执行顺序无关。因此影子操作被构造为一系列对CRDT的update操作，这些update操作通过构造而可交换。

为了完成任务2，我们只需要判断它是否是不变量安全的。这个问题有两种解决方向：
1. 动态解决方案，运行时决定何时生成影子操作和影子操作是否符合不变量安全性
2. 静态解决方案，它确定要对初始操作类型，参数和初始状态使用哪种组合，从而导致生成不变量安全的影子操作

这里结合上述两种思路提供了一种静态动态相结合的解决方案

### 实现架构
应用程序程序员将应用程序代码编写为一系列用Java编写的事务，这些事务访问数据库以存储持久状态。除了应用程序代码之外，程序员唯一需要提供的其他输入是CRDT注释，该注释指定了合并并发更新的语义和一组特定于应用程序的不变量。

静态分析器随后根据每个事务的代码创建影子操作模板，其中这些模板表示CRDT库中函数的不同调用序列。 分析器还计算出每个模板始终安全所需的最弱前提条件。

在运行时，应用程序服务器同时运行java代码和运行时检查器，并和数据库服务器和复制层进行交互。

当执行一件事务时，应用服务会运行生成器操作并将所有的操作副作用进行合计，当生成器调用提交操作时，会创建一个影子操作，该影子操作由CRDT库中的一系列调用组成。

然后将此影子操作馈送到最弱的前提条件检查器，以确定它属于哪个静态模板，以及该操作保持不变量安全所需的前提条件是什么，被涂色的影子操作随后反馈到复制系统用于实现多级一致性

### 生成影子操作

1. 许多用用基于两层模型构建，其中所有的持久状态都存储在关系数据库中通过数据库命令进行访问
2. 利用CRDT
综上，我们可以专注于调整SQL命令的实现以访问CRDT。

但是由于相同的数据库操作可能有不同的语义，在一些语义选择方面我们必须要求开发者进行介入和说明

#### 运行时生成影子操作
有了开发者的模式注释，运行时生成可交换的影子操作就很简单了。

思路就是当接收到新的用户请求时调用原始操作，但是不同之处在于，对数据库中所有执行命令的调用都被修改后的JDBC驱动程序拦截，该驱动程序随着原始操作的进行而构建包括影子操作的CRDT操作序列。

### 影子操作的涂色
静态情况下执行最保守判断，若静态判断该操作为红色，动态判断时再进一步进行检查。在当前情况下可以遍历所有可能，因此执行静态判断几乎相当于查表。

代码里常规的循环情况可能会导致无穷多的CRDT操作，这种情况下需要程序员指定循环不变量指导最弱的前提计算。另一种方法是简化循环的情况从而得到一个较简单的解决方案。

简化的情况：在大部分时候，循环迭代是相互独立的，每次迭代中修改的状态部分是不相交的。基于这种简化的情况做了一些工作。

运行时计算：通过将此操作与其对应的模板进行匹配来获取其最弱的前提条件，通过用此操作携带的值替换条件中的变量来评估条件。

模板/影子操作匹配：在运行时，我们必须在静态分析过程中创建的字典中查找与每个影子操作对应的模板。执行此查找的挑战在于，它需要确定与采用的路径相对应的影子操作的标识符，并且必须通过仅考虑由运行时控制的操作（即CRDT操作）来完成此操作。 这解释了为什么词典键仅包含CRDT操作。 使用影子操作标识符，可以通过使用搜索树有效地将运行时采用的路径与字典中存在的键进行匹配。

最弱前提条件检查：最后，一旦检索到对应于特定阴影操作的模板的最弱前提条件，我们便会根据阴影操作的CRDT参数评估该前提条件。 这可以通过简单地将前提条件中的变量替换为其实例化的值并将最终表达式评估为true或false来实现。 如果评估最弱的前提条件为true，则将阴影操作标记为蓝色，否则将阴影操作标记为红色。

### future work
1. CRDT库不完整
2. 使用SIEVE运行非复制系统的应用程序会导致性能下降
3. 循环情况的全面考察


# PoR一致性

先前将粗粒度操作分类为两个一致性级别的做法可能是保守的，并且某些服务可能会在协调级别方面受益于额外的灵活性。

### 贡献
1. 我们把能够将强一致性操作完全排序的粗粒度约束分解一个细粒度的约束集合，以此概括二分一致性背后的原理。每个细粒度的约束仅规定一对操作之间的顺序。PoR一致性就要求就要求所有的操作的顺序都满足这组限制。
2. 设计分析程序来为每一个应用寻找一组最小限制。
3. 提出了一种高效的协调服务，该功能可以通过考虑运行时测量的部署特征来帮助复制服务使用最高效的协议。因为提出给定对操作可见的一组限制，确保复制服务中的良好性能的关键方面是以有效的方式实施这些限制。事实上存在好几种协调技术/协议可以用来施加约束，比如Paxos,分布式锁，全局barriers。

### 与先前研究的区别和进步
1. PoR一致性使用操作对之间的可见性限制来表达一致性语义，从而在性能和一致性之间提供了可微调的折衷方案。并且PoR一致性还考虑了不变量一致性
2. 我们通过考虑并发执行对实现状态收敛和不变量保护的影响来进行分析以提取成对的冲突操作。不受冲突关系限制的操作可以首先被单个副本接受，然后异步复制到其他副本。
3. 设计了关于可交换性和不变量保存的一套全面且细粒度的分析系统，以尽可能避免副本系统之间协调，这些技术也与我们的建议兼容，因此我们可以在运行分析之前将它们应用于修剪非关键代码段。


### PoR一致性

PoR主要包括三个组成部分：
1. 一组限制
2. 受限偏序（或简称R阶），它建立了一个与操作可见性关系相关的操作的（全局）偏序
3. 一组指定站点的因果序列，对应本地操作的总顺序

定义1：（约束）给定一个操作集U，约束是关于U*U的对称二元关系。
解释：集合U中的任意两个操作u,v，若是存在约束r(u,v)，则他们在任何偏序关系中都必须严格有序。

定义2：（受限偏序）给定一个操作集U，给定一组U上的约束集R，一个受限偏序就是一个满足以下要求的偏序关系：任何两个被R中某个约束所限制的操作，在偏序关系中都必须严格有序

定义3：（合法序列）若O'=(U,<)是O的一个线性延拓，即是满足所有O中顺序关系的完全排序序列，则是受限偏序O=(U,<<)的一个合法序列

定义4：（合法因果序列）给定站点i，受限偏序O=(U,<<)和站点i接收到的生成器操作集Vi，当Oi=(U+Vi,<i)满足下列条件时，Oi是站点i的一个合法因果序列
+ Oi中任两个操作先后有序
+ (Ui,<i)是O的合法序列
+ Vi中的任意生成器操作gv生成的影子操作hv(S)中的状态S是Oi中gv之前所有的影子操作作用在站点i之后的站点状态
+ 对任意Vi中的操作gv，U中的任意操作hu(S),Oi中存在hu(S) <i gv当且仅当O中存在hu(S)<<hv(S')

定义5：（PoR一致性）若一个包含约束集R的复制系统X中应用在每个站点i上的操作序列是某个共同受限偏序O的因果合法序列则满足PoR一致性

### 约束的推导
与红蓝一致性不同，这里若两个操作不可交换，我们只要求这两个操作之间有序即可，而不要求这两个操作相对于所有其他操作都有固定的先后顺序。
为了在保证不变量安全性的同时进行优化，尝试将仅导致不变违规的操作与其他操作区分开，引入了I-conflict set这个概念，它定义了当系统以无协调的方式并发运行时会导致破坏不变量的最小影子操作集。

定理1：一个约束集为R的满足PoR一致性的系统是收敛的当且仅当对于影子操作集中任两个操作u,v，若他们不可交换（交换执行顺序后结果不同），则R中必存在约束r(u,v)

定义6：（I-conflict set）满足以下要求的影子操作集G是I-conflict set：
+ G中的任意一个操作都不是不变量安全的
+ G中包含至少一个操作
+ G是最小的，即去掉任意一个操作后剩余的操作的一个任意序列总能导致某个状态在应用序列后仍然是状态有效的（没有违背某个不变量的要求）的。

定理2：给定一个PoR一致性系统X和X上的约束集R(X),系统X从一个有效状态开始执行指令序列，若以下条件能够满足，则系统在执行操作时不会经历任何无效状态：
+ 对于它的任意一个I-conflict set，R(X)中至少存在一个约束r(u,v)，u,v是这个set中的操作
+ 若u,v在R（X）中存在约束r(u,v)，则u和v不可交换

ps。幂集是原集合的所有子集构成的集合


### Olisipo

给定约束r(u,v)

Sym(对称协议)：要求u和v相互协调以建立他们之间的顺序

Asym(不对称协议)：仅要求u通知限制v中的对应操作有关它的存在，从而为u和v提供了不同的处理，而如果没有u，则允许v快速执行而无需协调操作正在同时运行。（u和v对换也可以）

### future work
1. 没有探讨不对称限制的存在，也没有评估不对称限制对协调成本的影响
2. PoR一致性的采用要求程序员手动应用前面描述的静态分析，以便确定发散状态或违反不变式的可能性，以便获得最小限度的限制。希望能自动化
3. Olisipo应该继续加入其他的协调协议
4. 使olisipo能够动态测量不同操作的频率并在运行时进行协议的调换
