1. 在一个提供多级一致性的系统中如何判断在什么条件下让什么操作使用弱一致性？（红蓝一致性）
2. 上述分类是否可以自动化实现？（SIEVE）
3. 是否有一种通用的方式表达各种一致性要求并利用它来最大程度减少所需的协调通信量，实现性能最优？（细粒度的一致性）（部分有序限制POR一致性理论）

# Gemini
相反，我们首先乐观地在其主站点上运行了生成器操作，然后根据本地状态和用户输入推测性地生成了一个暂定的影子操作。如果相关的影子操作是蓝色的，那么本地站点就可以立即响应该操作而不需要联系远程的复制系统。否则，副本系统之间就必须相互通信为所有的红色影子操作建立一个统一的顺序，并确保这个影子操作的生成状态符合要求

对生成器操作的要求：
1. 它们不应该干扰其他的并发操作
2. there is no need for them to make their identified side effects persistent（？）

综上，认为基于锁机制的并发控制解决方案过于保守，转而使用乐观并发控制（OCC）。

1. 使用时间戳来决定影子操作能否成功完成，即影子操作能否被其他站点接受并按序加入全局的红蓝序序列中，为了确保不同的站点不会把一个红色操作的序列号发给不同的两个红色操作，我们使用一种令牌传递方案，只有持有令牌的站点中的协调器有权赋予红色操作在全局红蓝序中的序列号
2. 当生成器操作完成后，相关的影子操作也已生成完毕并使用先前算法进行了上色，这些操作随机被送往协调器来判断是否与全局的红蓝序相适配。若操作为蓝，协调器只进行一个时间戳的连贯性检查，若是红色，协调器就要判断生成该操作的状态是否反映了在其之前的一组红色操作应用在“初始状态”后的状态。
> 检查方式：首先协调器等待自己所属的站点获取令牌，随后协调器进行读写冲突检查：1.请求待定操作要写数据对象的锁，防止本地的并发挂起影子操作继续进行2.检查挂起影子操作的读数据集合是否已经被其他已接受的且接受时间是在生成当前影子操作到进行读写冲突检查之间的影子操作上锁和修改
3. 将蓝色操作标记为只读的（性能提升）

# 未来可以考虑的工作和当前解决方案的限制
1. 红蓝一致性提供的是一种粗粒度的分类方案，当应用需要比强一致性和弱一致性更细的一致性划分时，使用当前方案可能会导致较保守的红蓝分类（红多蓝少）
2. 人工在并发的应用环境下进行操作可交换的判断，影子操作的生成等工作较困难，需要自动化工具
3. 使用令牌传递方案来提供强一致性效率和容错性较低，可以考虑paxos
4. 每个站点对于接收到的所有操作都会分配单调时间戳，导致其内部的所有操作是完全有序的，但蓝色操作本来是可以不需要有序的，我们这种全排序的行为会限制站点的并发量和性能。
